@TranslatedBy("plantuml")
@NeedReview public static StarVoid dttree(Dict_t dt, StarVoid obj, int type) {
	Dtlink_t	root, t=null;
	int		cmp;
	size_t sz;
	OFFSET lk;
	OFFSET ky;
	StarVoid		o, k=null, key=null;
	Dtlink_t	l, r, me=null;
	final Dtlink_t link = new Dtlink_t();
	int		n, minp;
	int turn[] = new int[4*8 - 2];
	Dtcompar_f	cmpf;
	Dtdisc_t	disc;
	if ((dt.data.type&010000)!=0) dtrestore(dt,null);
	disc = dt.disc; ky = disc.key; sz = disc.size; lk = disc.link; cmpf = disc.comparf;
	dt.type &= ~0100000;
	root = dt.data.here;
	if(N(obj))
	{	if(N(root) || N(type&(0000100|0000200|0000400)) )
			return null;
		if((type&0000100)!=0) /* delete all objects */
		{	if(disc.freef!=null || isStrictNegative(disc.link))
			{	do
				{	while((t = root.hl._left())!=null )
						{ root.hl._left(t.right); t.right = root; root = t;}
					t = root.right;
					if(disc.freef!=null)
						disc.freef.function(dt,(isStrictNegative(lk) ? ((Dthold_t)(root.castTo(Dthold_t.class))).obj : root.substractByte(lk) ),disc);
					if(isStrictNegative(disc.link))
						dt.memoryf.function(dt,root,null,disc);
				} while((root = t)!=null );
			}
			dt.data.size = 0;
			dt.data.here = null;
			return null;
		}
		else /* computing largest/smallest element */
		{	if((type&0000400)!=0)
			{	while((t = root.right)!=null )
					{root.right = t.hl._left(); t.hl._left(root); root = t;}
			}
			else /* type&DT_FIRST */
			{	while((t = root.hl._left())!=null )
					{root.hl._left(t.right); t.right = root; root = t;}
			}
			dt.data.here = root;
			return (isStrictNegative(lk) ? ((Dthold_t)(root.castTo(Dthold_t.class))).obj : root.substractByte(lk) );
		}
	}
	/* note that link.right is LEFT tree and link.left is RIGHT tree */
	l = r = link;
	/* allow apps to delete an object "actually" in the dictionary */
	if(dt.meth.type == 0000010 && (type&(0000002|0010000))!=0 )
	{	key = isStrictNegative(sz)  ? ((StarStarChar)obj.addByte(ky)).get() : obj.addByte(ky);
		for(o = dt.searchf.function(dt,obj,0000004); o!=null; o = dt.searchf.function(dt,o,0000010) )
		{	k = isStrictNegative(sz)  ? ((StarStarChar)o.addByte(ky)).get() : o.addByte(ky);
			if((cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) ) != 0)
				break;
			if(o == obj)
			{	root = dt.data.here;
				l.right = root.hl._left();
				r.hl._left(root.right);
				return dttree_goto_dt_delete();
			}
		}
	}
	boolean dttree_goto_do_search = false;
	if((type&(0001000|0000004|0000001|0004000))!=0)
	{	key = ((type&0001000)!=0) ? obj : isStrictNegative(sz)  ? ((StarStarChar)obj.addByte(ky)).get() : obj.addByte(ky);
		if(root!=null)
			dttree_goto_do_search = true;
	}
	else if((type&0000040)!=0)
	{	me = (Dtlink_t)obj;
		obj = isStrictNegative(lk) ? ((Dthold_t)me.castTo(Dthold_t.class)).obj : me.substractByte(lk);
		key = isStrictNegative(sz)  ? ((StarStarChar)obj.addByte(ky)).get() : obj.addByte(ky);
		if(root!=null)
			dttree_goto_do_search = true;
	}
	else if(root!=null && (isStrictNegative(lk) ? ((Dthold_t)root.castTo(Dthold_t.class)).obj : root.substractByte(lk) ) != obj)
	{	key = isStrictNegative(sz)  ? ((StarStarChar)obj.addByte(ky)).get() : obj.addByte(ky);
		dttree_goto_do_search = true;
	}
	if (dttree_goto_do_search) {
		if(dt.meth.type == 0000004 &&
		   (minp = dt.data.minp) != 0 && (type&(0001000|0000004))!=0 )
		{	/* simple search, note that minp should be even */
			for(t = root, n = 0; n < minp; ++n)
			{	k = (isStrictNegative(lk) ? ((Dthold_t)t.castTo(Dthold_t.class)).obj : t.substractByte(lk) ); k = isStrictNegative(sz)  ? ((StarStarChar)k.addByte(ky)).get() : k.addByte(ky);
				if((cmp = (cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) )) == 0)
					return (isStrictNegative(lk) ? ((Dthold_t)t.castTo(Dthold_t.class)).obj : t.substractByte(lk) );
				else
				{	turn[n] = cmp;	
					if(N(t = cmp < 0 ? t.hl._left() : t.right) )
						return null;
				}
			}
			/* exceed search length, top-down splay now */
			for(n = 0; n < minp; n += 2)
			{	if(turn[n] < 0)
				{	t = root.hl._left();
					if(turn[n+1] < 0)
					{	root.hl._left(t.right); t.right = root;
						r = r.hl._left(t);
						root = t.hl._left();
					}
					else
					{	l = l.right = t;
						r = r.hl._left(root);
						root = t.right;
					}
				}
				else
				{	t = root.right;
					if(turn[n+1] > 0)
					{	root.right = t.hl._left(); t.hl._left(root);
						l = l.right = t;
						root = t.right;
					}
					else
					{	r = r.hl._left(t);
						l = l.right = root;
						root = t.hl._left();
					}
				}
			}
		}
		while(true)
		{	k = (isStrictNegative(lk) ? ((Dthold_t)root.castTo(Dthold_t.class)).obj : root.substractByte(lk) ); k = isStrictNegative(sz)  ? ((StarStarChar)k.addByte(ky)).get() : k.addByte(ky);
			if((cmp = (cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) )) == 0)
				break;
			else if(cmp < 0)
			{	if((t = root.hl._left())!=null )
				{	k = isStrictNegative(lk) ? ((Dthold_t)t.castTo(Dthold_t.class)).obj : t.substractByte(lk); k = isStrictNegative(sz)  ? ((StarStarChar)k.addByte(ky)).get() : k.addByte(ky);
					if((cmp = (cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) )) < 0)
					{	root.hl._left(t.right); t.right = root;
						r = r.hl._left(t);
						if(N(root = t.hl._left()) )
							break;
					}
					else if(cmp == 0)
					{	r = r.hl._left(root);
						root = t;
						break;
					}
					else /* if(cmp > 0) */
					{	l = l.right = t ;
						r = r.hl._left(root);
						if(N(root = t.right) )
							break;
					}
				}
				else
				{	r = r.hl._left(root);
					root = null;
					break;
				}
			}
			else /* if(cmp > 0) */
			{	if((t = root.right)!=null )
				{	k = isStrictNegative(lk) ? ((Dthold_t)t.castTo(Dthold_t.class)).obj : t.substractByte(lk); k = isStrictNegative(sz)  ? ((StarStarChar)k.addByte(ky)).get() : k.addByte(ky);
					if((cmp = (cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) )) > 0)
					{	root.right = t.hl._left(); t.hl._left(root);
						l = l.right = t;
						if(N(root = t.right) )
							break;
					}
					else if(cmp == 0)
					{	l = l.right = root;
						root = t;
						break;
					}
					else /* if(cmp < 0) */
					{	r = r.hl._left(t);
						l = l.right = root;
						if(N(root = t.hl._left()) )
							break;
					}
				}
				else
				{	l = l.right = root;
					root = null;
					break;
				}
			}
		}		
	}
	if(root!=null)
	{	/* found it, now isolate it */
		dt.type |= 0100000;
		l.right = root.hl._left();
		r.hl._left(root.right);
		if((type&(0000004|0001000))!=0)
		{
			return goto_has_root(root, link, type, key, dt, lk, r, t, k, sz, ky, cmpf, disc);
		}
		else if((type&0000010)!=0)
		{	root.hl._left(link.right);
		root.right = null;
		link.right = root;
		return goto_dt_next(root, link, t, r, dt, obj, type, key, lk, k, sz, ky, cmpf, disc);
		}
		else if((type&0000020)!=0)
		{
throw new UnsupportedOperationException();
		}
		else if((type&(0000002|0010000))!=0)
		{	/* taking an object out of the dictionary */
throw new UnsupportedOperationException();
		}
		else if((type&(0000001|0004000))!=0)
		{
throw new UnsupportedOperationException();
		}
		else if((type&0000040)!=0) /* a duplicate */
		{
throw new UnsupportedOperationException();
		}
throw new UnsupportedOperationException();
	}
	else
	{	/* not found, finish up LEFT and RIGHT trees */
		r.hl._left(null);
		l.right = null;
		if((type&0000010)!=0)
			return goto_dt_next(root, link, t, r, dt, obj, type, key, lk, k, sz, ky, cmpf, disc);
		else if((type&0000020)!=0)
			return goto_dt_prev();
		else if((type&(0000004|0001000))!=0)
		{ return goto_no_root(t, r, dt, link, obj, type);
		}
		else if((type&(0000001|0004000))!=0)
		{ return goto_dt_insert(disc, type, obj, lk, root, dt, t, r, link, key, k, sz, ky, cmpf);
		}
		else if((type&0000040)!=0)
		{	root = me;
			dt.data.size += 1;
			return goto_has_root(root, link, type, key, dt, lk, r, t, k, sz, ky, cmpf, disc);
		}
		else /*if(type&DT_DELETE)*/
		{	obj = null;
			return goto_no_root(t, r, dt, link, obj, type);
		}
	}
}
private static StarVoid goto_no_root(Dtlink_t t, Dtlink_t r, Dict_t dt, Dtlink_t link, StarVoid obj, int type) {
	while((t = r.hl._left())!=null )
		r = t;
	r.hl._left(link.right);
	dt.data.here = link.hl._left();
	return (type&0000002)!=0 ? obj : null;
	}
private static StarVoid goto_dt_insert(Dtdisc_t disc, int type, StarVoid obj, OFFSET lk, Dtlink_t root, Dict_t dt, Dtlink_t t, Dtlink_t r, Dtlink_t link, StarVoid key, StarVoid k, size_t sz, OFFSET ky, Dtcompar_f cmpf) {
			if(disc.makef!=null && (type&0000001)!=0)
				obj = disc.makef.function(dt,obj,disc);
			if(obj!=null)
			{	if(isPositiveOrZero(lk))
					root = (Dtlink_t) obj.addByte(lk).castTo(Dtlink_t.class);
				else
				{	root = (Dtlink_t) dt.memoryf.function
						(dt,null,sizeof(Dthold_t.class),disc);
					if(root!=null)
						((Dthold_t)root.castTo(Dthold_t.class)).obj = obj;
					else if(disc.makef!=null && disc.freef!=null &&
						(type&0000001)!=0)
						disc.freef.function(dt,obj,disc);
				}
			}
			if(root!=null)
			{	if(dt.data.size >= 0)
					dt.data.size += 1;
				return goto_has_root(root, link, type, key, dt, lk, r, t, k, sz, ky, cmpf, disc);
			}
			else	return goto_no_root(t, r, dt, link, obj, type);
	}
private static StarVoid goto_has_root(Dtlink_t root, Dtlink_t link, int type, StarVoid key, Dict_t dt, OFFSET lk, Dtlink_t r, Dtlink_t t, StarVoid k, size_t sz, OFFSET ky, Dtcompar_f cmpf, Dtdisc_t disc) {
			root.hl._left(link.right);
			root.right = link.hl._left();
			if((dt.meth.type&0000010)!=0 && (type&(0000004|0001000))!=0 )
			{	key = (isStrictNegative(lk) ? ((Dthold_t)root.castTo(Dthold_t.class)).obj : root.substractByte(lk) ); key = (isStrictNegative(sz)  ? ((StarStarChar)key.addByte(ky)).get() : key.addByte(ky));
				while((t = root.hl._left())!=null )
				{	/* find max of left subtree */
					while((r = t.right)!=null )
						t.right = r.hl._left(); r.hl._left(t); t = r;
					root.hl._left(t);
					/* now see if it's in the same group */
					k = (isStrictNegative(lk) ? ((Dthold_t)t.castTo(Dthold_t.class)).obj : t.substractByte(lk) ); k = isStrictNegative(sz) ? ((StarStarChar)k.addByte(ky)).get() : k.addByte(ky);
					if((cmpf!=null ? cmpf.function(dt,key,k,disc) : (isNegativeOrNull(sz) ?strcmp(key,k) : memcmp(key,k,sz)) ) != 0)
						break;
					root.hl._left(t.right); t.right = root; root = t;
				}
			}
			dt.data.here = root;
			return (isStrictNegative(lk) ? ((Dthold_t)(root.castTo(Dthold_t.class))).obj : root.substractByte(lk) );
	}
private static StarVoid dttree_goto_dt_delete() {
	throw new UnsupportedOperationException();
	}
private static StarVoid goto_dt_next(Dtlink_t root, Dtlink_t link, Dtlink_t t, Dtlink_t r, Dict_t dt, StarVoid obj, int type,
		StarVoid key, OFFSET lk, StarVoid k, size_t sz, OFFSET ky, Dtcompar_f cmpf, Dtdisc_t disc) {
	if((root = link.hl._left())!=null )	
	{	while((t = root.hl._left())!=null )
			root.hl._left(t.right); t.right = root; root = t;
		link.hl._left(root.right);
		return goto_has_root(root, link, type, key, dt, lk, r, t, k, sz, ky, cmpf, disc);
	}
	else	return goto_no_root(t, r, dt, link, obj, type);
}
private static StarVoid goto_dt_prev() {
throw new UnsupportedOperationException();
}
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
static void* dttree(Dt_t* dt, void* obj, int type)
{
	Dtlink_t	*root, *t;
	int		cmp, lk, sz, ky;
	void		*o, *k, *key;
	Dtlink_t	*l, *r, *me, link;
	int		n, minp, turn[(sizeof(size_t)*8 - 2)];
	Dtcompar_f	cmpf;
	Dtdisc_t*	disc;
	((dt->data->type&010000) ? dtrestore(dt,((Dtlink_t*)0)) : 0);
	disc = dt->disc; (ky = disc->key, sz = disc->size, lk = disc->link, cmpf = disc->comparf);
	dt->type &= ~0100000;
	root = dt->data->here;
	if(!obj)
	{	if(!root || !(type&(0000100|0000200|0000400)) )
			return ((void*)0);
		if(type&0000100) /* delete all objects */
		{	if(disc->freef || disc->link < 0)
			{	do
				{	while((t = root->hl._left) )
						(((root)->hl._left = (t)->right, (t)->right = (root)), (root) = (t));
					t = root->right;
					if(disc->freef)
						(*disc->freef)(dt,(lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) ),disc);
					if(disc->link < 0)
						(*dt->memoryf)(dt,(void*)root,0,disc);
				} while((root = t) );
			}
			dt->data->size = 0;
			dt->data->here = ((Dtlink_t*)0);
			return ((void*)0);
		}
		else /* computing largest/smallest element */
		{	if(type&0000400)
			{	while((t = root->right) )
					(((root)->right = (t)->hl._left, (t)->hl._left = (root)), (root) = (t));
			}
			else /* type&DT_FIRST */
			{	while((t = root->hl._left) )
					(((root)->hl._left = (t)->right, (t)->right = (root)), (root) = (t));
			}
			dt->data->here = root;
			return (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) );
		}
	}
	/* note that link.right is LEFT tree and link.left is RIGHT tree */
	l = r = &link;
	/* allow apps to delete an object "actually" in the dictionary */
	if(dt->meth->type == 0000010 && (type&(0000002|0010000)) )
	{	key = (void*)(sz < 0 ? *((char**)((char*)(obj)+ky)) : ((char*)(obj)+ky));
		for(o = (*(((Dt_t*)(dt))->searchf))((dt),(void*)(obj),0000004); o; o = (*(((Dt_t*)(dt))->searchf))((dt),(void*)(o),0000010) )
		{	k = (void*)(sz < 0 ? *((char**)((char*)(o)+ky)) : ((char*)(o)+ky));
			if((cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) ) != 0)
				break;
			if(o == obj)
			{	root = dt->data->here;
				l->right = root->hl._left;
				r->hl._left  = root->right;
				goto dt_delete;
			}
		}
	}
	if(type&(0001000|0000004|0000001|0004000))
	{	key = (type&0001000) ? obj : (void*)(sz < 0 ? *((char**)((char*)(obj)+ky)) : ((char*)(obj)+ky));
		if(root)
			goto do_search;
	}
	else if(type&0000040)
	{	me = (Dtlink_t*)obj;
		obj = (lk < 0 ? ((Dthold_t*)(me))->obj : (void*)((char*)(me) - lk) );
		key = (void*)(sz < 0 ? *((char**)((char*)(obj)+ky)) : ((char*)(obj)+ky));
		if(root)
			goto do_search;
	}
	else if(root && (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) ) != obj)
	{	key = (void*)(sz < 0 ? *((char**)((char*)(obj)+ky)) : ((char*)(obj)+ky));
	do_search:
		if(dt->meth->type == 0000004 &&
		   (minp = dt->data->minp) != 0 && (type&(0001000|0000004)) )
		{	/* simple search, note that minp should be even */
			for(t = root, n = 0; n < minp; ++n)
			{	k = (lk < 0 ? ((Dthold_t*)(t))->obj : (void*)((char*)(t) - lk) ); k = (void*)(sz < 0 ? *((char**)((char*)(k)+ky)) : ((char*)(k)+ky));
				if((cmp = (cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) )) == 0)
					return (lk < 0 ? ((Dthold_t*)(t))->obj : (void*)((char*)(t) - lk) );
				else
				{	turn[n] = cmp;	
					if(!(t = cmp < 0 ? t->hl._left : t->right) )
						return ((void*)0);
				}
			}
			/* exceed search length, top-down splay now */
			for(n = 0; n < minp; n += 2)
			{	if(turn[n] < 0)
				{	t = root->hl._left;
					if(turn[n+1] < 0)
					{	((root)->hl._left = (t)->right, (t)->right = (root));
						((r) = (r)->hl._left = (t) );
						root = t->hl._left;
					}
					else
					{	((l) = (l)->right = (t) );
						((r) = (r)->hl._left = (root) );
						root = t->right;
					}
				}
				else
				{	t = root->right;
					if(turn[n+1] > 0)
					{	((root)->right = (t)->hl._left, (t)->hl._left = (root));
						((l) = (l)->right = (t) );
						root = t->right;
					}
					else
					{	((r) = (r)->hl._left = (t) );
						((l) = (l)->right = (root) );
						root = t->hl._left;
					}
				}
			}
		}
		while(1)
		{	k = (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) ); k = (void*)(sz < 0 ? *((char**)((char*)(k)+ky)) : ((char*)(k)+ky));
			if((cmp = (cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) )) == 0)
				break;
			else if(cmp < 0)
			{	if((t = root->hl._left) )
				{	k = (lk < 0 ? ((Dthold_t*)(t))->obj : (void*)((char*)(t) - lk) ); k = (void*)(sz < 0 ? *((char**)((char*)(k)+ky)) : ((char*)(k)+ky));
					if((cmp = (cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) )) < 0)
					{	((root)->hl._left = (t)->right, (t)->right = (root));
						((r) = (r)->hl._left = (t) );
						if(!(root = t->hl._left) )
							break;
					}
					else if(cmp == 0)
					{	((r) = (r)->hl._left = (root) );
						root = t;
						break;
					}
					else /* if(cmp > 0) */
					{	((l) = (l)->right = (t) );
						((r) = (r)->hl._left = (root) );
						if(!(root = t->right) )
							break;
					}
				}
				else
				{	((r) = (r)->hl._left = (root) );
					root = ((Dtlink_t*)0);
					break;
				}
			}
			else /* if(cmp > 0) */
			{	if((t = root->right) )
				{	k = (lk < 0 ? ((Dthold_t*)(t))->obj : (void*)((char*)(t) - lk) ); k = (void*)(sz < 0 ? *((char**)((char*)(k)+ky)) : ((char*)(k)+ky));
					if((cmp = (cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) )) > 0)
					{	((root)->right = (t)->hl._left, (t)->hl._left = (root));
						((l) = (l)->right = (t) );
						if(!(root = t->right) )
							break;
					}
					else if(cmp == 0)
					{	((l) = (l)->right = (root) );
						root = t;
						break;
					}
					else /* if(cmp < 0) */
					{	((r) = (r)->hl._left = (t) );
						((l) = (l)->right = (root) );
						if(!(root = t->hl._left) )
							break;
					}
				}
				else
				{	((l) = (l)->right = (root) );
					root = ((Dtlink_t*)0);
					break;
				}
			}
		}
	}
	if(root)
	{	/* found it, now isolate it */
		dt->type |= 0100000;
		l->right = root->hl._left;
		r->hl._left = root->right;
		if(type&(0000004|0001000))
		{ has_root:
			root->hl._left = link.right;
			root->right = link.hl._left;
			if((dt->meth->type&0000010) && (type&(0000004|0001000)) )
			{	key = (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) ); key = (void*)(sz < 0 ? *((char**)((char*)(key)+ky)) : ((char*)(key)+ky));
				while((t = root->hl._left) )
				{	/* find max of left subtree */
					while((r = t->right) )
						(((t)->right = (r)->hl._left, (r)->hl._left = (t)), (t) = (r));
					root->hl._left = t;
					/* now see if it's in the same group */
					k = (lk < 0 ? ((Dthold_t*)(t))->obj : (void*)((char*)(t) - lk) ); k = (void*)(sz < 0 ? *((char**)((char*)(k)+ky)) : ((char*)(k)+ky));
					if((cmpf ? (*cmpf)(dt,key,k,disc) : (sz <= 0 ? strcmp(key,k) : memcmp(key,k,sz)) ) != 0)
						break;
					(((root)->hl._left = (t)->right, (t)->right = (root)), (root) = (t));
				}
			}
			dt->data->here = root;
			return (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) );
		}
		else if(type&0000010)
		{	root->hl._left = link.right;
			root->right = ((Dtlink_t*)0);
			link.right = root;
		dt_next:
			if((root = link.hl._left) )	
			{	while((t = root->hl._left) )
					(((root)->hl._left = (t)->right, (t)->right = (root)), (root) = (t));
				link.hl._left = root->right;
				goto has_root;
			}
			else	goto no_root;
		}
		else if(type&0000020)
		{	root->right = link.hl._left;
			root->hl._left = ((Dtlink_t*)0);
			link.hl._left = root;
		dt_prev:
			if((root = link.right) )
			{	while((t = root->right) )
					(((root)->right = (t)->hl._left, (t)->hl._left = (root)), (root) = (t));
				link.right = root->hl._left;
				goto has_root;
			}
			else	goto no_root;
		}
		else if(type&(0000002|0010000))
		{	/* taking an object out of the dictionary */
		dt_delete:
			obj = (lk < 0 ? ((Dthold_t*)(root))->obj : (void*)((char*)(root) - lk) );
			if(disc->freef && (type&0000002))
				(*disc->freef)(dt,obj,disc);
			if(disc->link < 0)
				(*dt->memoryf)(dt,(void*)root,0,disc);
			if((dt->data->size -= 1) < 0)
				dt->data->size = -1;
			goto no_root;
		}
		else if(type&(0000001|0004000))
		{	if(dt->meth->type&0000004)
				goto has_root;
			else
			{	root->hl._left = ((Dtlink_t*)0);
				root->right = link.hl._left;
				link.hl._left = root;
				goto dt_insert;
			}
		}
		else if(type&0000040) /* a duplicate */
		{	if(dt->meth->type&0000004)
			{	if(disc->freef)
					(*disc->freef)(dt,obj,disc);
				if(disc->link < 0)
					(*dt->memoryf)(dt,(void*)me,0,disc);
			}
			else
			{	me->hl._left = ((Dtlink_t*)0);
				me->right = link.hl._left;
				link.hl._left = me;
				dt->data->size += 1;
			}
			goto has_root;
		}
	}
	else
	{	/* not found, finish up LEFT and RIGHT trees */
		r->hl._left = ((Dtlink_t*)0);
		l->right = ((Dtlink_t*)0);
		if(type&0000010)
			goto dt_next;
		else if(type&0000020)
			goto dt_prev;
		else if(type&(0000004|0001000))
		{ no_root:
			while((t = r->hl._left) )
				r = t;
			r->hl._left = link.right;
			dt->data->here = link.hl._left;
			return (type&0000002) ? obj : ((void*)0);
		}
		else if(type&(0000001|0004000))
		{ dt_insert:
			if(disc->makef && (type&0000001))
				obj = (*disc->makef)(dt,obj,disc);
			if(obj)
			{	if(lk >= 0)
					root = ((Dtlink_t*)((char*)(obj) + lk) );
				else
				{	root = (Dtlink_t*)(*dt->memoryf)
						(dt,((void*)0),sizeof(Dthold_t),disc);
					if(root)
						((Dthold_t*)root)->obj = obj;
					else if(disc->makef && disc->freef &&
						(type&0000001))
						(*disc->freef)(dt,obj,disc);
				}
			}
			if(root)
			{	if(dt->data->size >= 0)
					dt->data->size += 1;
				goto has_root;
			}
			else	goto no_root;
		}
		else if(type&0000040)
		{	root = me;
			dt->data->size += 1;
			goto has_root;
		}
		else /*if(type&DT_DELETE)*/
		{	obj = ((void*)0);
			goto no_root;
		}
	}
	return ((void*)0);
}

