@TranslatedBy("plantuml")
@HasQuestion("Better idea for REF management ?")
@NeedReview public static Dict_t dtopen(Dtdisc_t disc, Dtmethod_t meth) {
	Dict_t		dt = (Dict_t)Version;	/* shut-up unuse warning */
	int		e;
	Dtdata_t	data[] = new Dtdata_t[1];
	if(N(disc) || N(meth))
		return null;
	/* allocate space for dictionary */
	if (N(dt = (Dict_t) malloc(Dict_t.class)))
		return null;
	/* initialize all absolutely private data */
	dt.searchf = null;
	dt.meth = null;
	dt.disc = null;
	dtdisc(dt,disc,0);
	dt.type = 0;
	dt.nview = 0;
	dt.view = dt.walk = null;
	dt.user = null;
	if(disc.eventf!=null)
	{	/* if shared/persistent dictionary, get existing data */
		data = null;
		if((e = disc.eventf.function(dt,1,JUtils.ASREF(data),disc)) < 0)
			/* err_open: */	{free(dt); return null;}
		else if(e > 0)
		{	if(data!=null)
			{	if((data[0].type&meth.type)!=0) {
				//done:
				dt.data = data[0];
				dt.searchf = meth.searchf;
				dt.meth = meth;
				if(disc.eventf!=null)
					disc.eventf.function(dt, 5, dt, disc);
				return dt;
				}
				else	/* err_open: */	{free(dt); return null;}
			}
			if(N(disc.memoryf))
			/* err_open: */	{free(dt); return null;}
			free(dt);
			if(N(dt = (Dict_t) disc.memoryf.function(null, null, JUtils.sizeof(Dict_t.class), disc)) )
				return null;
			dt.searchf = null;
			dt.meth = null;
			dt.disc = null;
			dtdisc(dt,disc,0);
			dt.type = 1;
			dt.nview = 0;
			dt.view = dt.walk = null;
		}

	}
	/* allocate sharable data */
	if(N(data[0] = (Dtdata_t)dt.memoryf.function(dt, null, JUtils.sizeof(Dtdata_t.class), disc).castTo(Dtdata_t.class) ))
	/* err_open: */	{free(dt); return null;}
	data[0].type = meth.type;
	data[0].here = null;
	data[0].hh._htab(null);
	data[0].ntab = data[0].size = data[0].loop = 0;
	data[0].minp = 0;
	//done:
	dt.data = data[0];
	dt.searchf = meth.searchf;
	dt.meth = meth;
	if(disc.eventf!=null)
		disc.eventf.function(dt, 5, dt, disc);
	return dt;
}
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Dt_t* dtopen(Dtdisc_t* disc, Dtmethod_t* meth)
{
	Dt_t*		dt = (Dt_t*)Version;	/* shut-up unuse warning */
	register int		e;
	Dtdata_t*	data;
	if(!disc || !meth)
		return ((Dt_t*)0);
	/* allocate space for dictionary */
	if(!(dt = (Dt_t*) malloc(sizeof(Dt_t))))
		return ((Dt_t*)0);
	/* initialize all absolutely private data */
	dt->searchf = ((Dtsearch_f)0);
	dt->meth = ((Dtmethod_t*)0);
	dt->disc = ((Dtdisc_t*)0);
	dtdisc(dt,disc,0);
	dt->type = 0;
	dt->nview = 0;
	dt->view = dt->walk = ((Dt_t*)0);
	dt->user = ((void*)0);
	if(disc->eventf)
	{	/* if shared/persistent dictionary, get existing data */
		data = ((Dtdata_t*)0);
		if((e = (*disc->eventf)(dt,1,(void*)(&data),disc)) < 0)
			goto err_open;
		else if(e > 0)
		{	if(data)
			{	if(data->type&meth->type)
					goto done;
				else	goto err_open;
			}
			if(!disc->memoryf)
				goto err_open;
			free((void*)dt);
			if(!(dt = (*disc->memoryf)(0, 0, sizeof(Dt_t), disc)) )
				return ((Dt_t*)0);
			dt->searchf = ((Dtsearch_f)0);
			dt->meth = ((Dtmethod_t*)0);
			dt->disc = ((Dtdisc_t*)0);
			dtdisc(dt,disc,0);
			dt->type = 1;
			dt->nview = 0;
			dt->view = dt->walk = ((Dt_t*)0);
		}
	}
	/* allocate sharable data */
	if(!(data = (Dtdata_t*)(dt->memoryf)(dt,((void*)0),sizeof(Dtdata_t),disc)) )
	{ err_open:
		free((void*)dt);
		return ((Dt_t*)0);
	}
	data->type = meth->type;
	data->here = ((Dtlink_t*)0);
	data->hh._htab = ((Dtlink_t**)0);
	data->ntab = data->size = data->loop = 0;
	data->minp = 0;
done:
	dt->data = data;
	dt->searchf = meth->searchf;
	dt->meth = meth;
	if(disc->eventf)
		(*disc->eventf)(dt, 5, (void*)dt, disc);
	return dt;
}

