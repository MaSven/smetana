#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1





/* A lexical scanner generated by flex */









/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1





/* end standard C headers. */

/* flex integer type definitions */




/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */


















typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */







































/* C99 requires __STDC__ to be defined as 1. */













/* Returned upon end-of-file. */


/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */


/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */


/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */



/* Action number for EOF rule of a given start state. */


/* Special action meaning "start processing a new file". */




/* Size of default input buffer. */




/* The state buf must be large enough to hold one state per character in the main buffer.
 */




typedef struct aag_buffer_state *YY_BUFFER_STATE;




typedef size_t aag_size_t;


extern aag_size_t aagleng;

extern FILE *aagin, *aagout;





    
    
/* Return all but the first "n" matched characters back to the input stream. */

















struct aag_buffer_state
	{
	FILE *aag_input_file;

	char *aag_ch_buf;		/* input buffer */
	char *aag_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	aag_size_t aag_buf_size;

	/* Number of characters read into aag_ch_buf, not including EOB
	 * characters.
	 */
	aag_size_t aag_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int aag_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int aag_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int aag_at_bol;

    int aag_bs_lineno; /**< The line count. */
    int aag_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int aag_fill_buffer;

	int aag_buffer_status;



	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via aagrestart()), so that the user can continue scanning by
	 * just pointing aagin at a new input file.
	 */


	};


/* Stack of input buffers. */
static size_t aag_buffer_stack_top = 0; /**< index of top of stack. */
static size_t aag_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * aag_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */




/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */


/* aag_hold_char holds the character lost when aagtext is formed. */
static char aag_hold_char;
static aag_size_t aag_n_chars;		/* number of characters read into aag_ch_buf */
aag_size_t aagleng;

/* Points to current character in buffer. */
static char *aag_c_buf_p = (char *) 0;
static int aag_init = 0;		/* whether we need to initialize */
static int aag_start = 0;	/* start state number */

/* Flag which is used to allow aagwrap()'s to do buffer switches
 * instead of setting up a fresh aagin.  A bit of a hack ...
 */
static int aag_did_buffer_switch_on_eof;

void aagrestart (FILE *input_file  );
void aag_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE aag_create_buffer (FILE *file,int size  );
void aag_delete_buffer (YY_BUFFER_STATE b  );
void aag_flush_buffer (YY_BUFFER_STATE b  );
void aagpush_buffer_state (YY_BUFFER_STATE new_buffer  );
void aagpop_buffer_state (void );

static void aagensure_buffer_stack (void );
static void aag_load_buffer_state (void );
static void aag_init_buffer (YY_BUFFER_STATE b,FILE *file  );



YY_BUFFER_STATE aag_scan_buffer (char *base,aag_size_t size  );
YY_BUFFER_STATE aag_scan_string ( char *aag_str  );
YY_BUFFER_STATE aag_scan_bytes ( char *bytes,aag_size_t len  );

void *aagalloc (aag_size_t  );
void *aagrealloc (void *,aag_size_t  );
void aagfree (void *  );

























/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *aagin = (FILE *) 0, *aagout = (FILE *) 0;

typedef int aag_state_type;

extern int aaglineno;

int aaglineno = 1;

extern char *aagtext;


static aag_state_type aag_get_previous_state (void );
static aag_state_type aag_try_NUL_trans (aag_state_type current_state  );
static int aag_get_next_buffer (void );
static void aag_fatal_error ( char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up aagtext.
 */









/* This struct is not used in this scanner,
   but its presence is necessary. */
struct aag_trans_info
	{
	flex_int32_t aag_verify;
	flex_int32_t aag_nxt;
	};
static  flex_int16_t aag_accept[93] =
    {   0,
        0,    0,    4,    4,   27,   27,   32,   32,   35,   33,
       10,    2,   22,    9,   33,   33,   33,   21,   28,    1,
       20,   20,   20,   20,   20,   20,   20,    8,    4,    5,
       27,    2,   23,   27,   32,   31,   30,   29,    9,   19,
        0,   21,   18,   21,    3,    7,   21,   21,   20,   20,
       20,   20,   20,   20,   20,   20,    8,    4,    5,    5,
        6,   27,   26,   24,   25,   32,    7,   21,   20,   20,
       20,   20,   20,   20,   11,   20,   13,   20,   12,   20,
       20,   20,   14,   20,   20,   20,   16,   20,   15,   20,
       17,    0

    } ;

static  flex_int32_t aag_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
        1,    6,    1,    1,    7,    8,    9,   10,   10,   10,
       10,   10,   10,   10,   10,   10,   10,    1,    1,   11,
        1,   12,    1,   13,   14,   15,   16,   17,   18,   19,
       20,   21,   22,   19,   19,   19,   19,   23,   24,   25,
       19,   26,   27,   28,   29,   19,   19,   19,   19,   19,
        1,   30,    1,    1,   19,    1,   31,   32,   33,   34,

       35,   19,   36,   37,   38,   19,   19,   19,   19,   39,
       40,   41,   19,   42,   43,   44,   45,   19,   19,   19,
       19,   19,    1,    1,    1,    1,    1,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   46,   19,   19,   19,
       47,   19,   19,   19,   19,   19,   19,   19,   19,   19,

       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   48,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19
    } ;

static  flex_int32_t aag_meta[49] =
    {   0,
        1,    1,    2,    3,    1,    4,    1,    5,    1,    6,
        7,    7,    1,    6,    6,    6,    6,    6,    6,    6,
        6,    6,    6,    6,    6,    6,    6,    6,    6,    3,
        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
        6,    6,    6,    6,    6,    6,    6,    6
    } ;

static  flex_int16_t aag_base[105] =
    {   0,
        0,  142,   46,   47,   51,   53,   48,   55,  146,  230,
      230,  230,  230,    0,   61,  125,   55,   55,  230,  230,
        0,   40,   53,   46,   50,   47,   81,    0,    0,   71,
        0,    0,  230,   81,    0,  230,  230,  230,    0,  230,
      113,   85,  230,   86,  230,    0,   89,  230,    0,   62,
       66,   75,   83,   77,   86,   67,    0,    0,   98,   99,
      230,    0,  230,  230,  230,    0,    0,  102,   83,   95,
       90,   98,   98,  101,    0,  108,    0,  103,    0,  110,
      102,  104,    0,  104,  120,  117,    0,  116,    0,  121,
        0,  230,  158,  165,  172,  179,  182,   73,  188,  195,

      202,  209,  216,  222
    } ;

static  flex_int16_t aag_def[105] =
    {   0,
       92,    1,   93,   93,   94,   94,   95,   95,   92,   92,
       92,   92,   92,   96,   92,   92,   92,   97,   92,   92,
       98,   98,   98,   98,   98,   98,   98,   99,  100,  101,
      102,  102,   92,   92,  103,   92,   92,   92,   96,   92,
       92,   97,   92,   97,   92,  104,   97,   92,   98,   98,
       98,   98,   98,   98,   98,   98,   99,  100,  101,  101,
       92,  102,   92,   92,   92,  103,  104,   97,   98,   98,
       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
       98,    0,   92,   92,   92,   92,   92,   92,   92,   92,

       92,   92,   92,   92
    } ;

static  flex_int16_t aag_nxt[279] =
    {   0,
       10,   11,   12,   13,   14,   10,   15,   16,   17,   18,
       19,   10,   20,   21,   21,   21,   22,   23,   21,   24,
       21,   21,   25,   21,   21,   21,   26,   21,   21,   10,
       21,   21,   21,   22,   23,   24,   21,   21,   25,   21,
       21,   21,   26,   21,   21,   21,   21,   27,   12,   12,
       36,   30,   30,   32,   33,   32,   33,   36,   37,   38,
       45,   50,   47,   46,   42,   37,   38,   40,   41,   51,
       42,   52,   43,   53,   54,   55,   60,   50,   49,   61,
       34,   69,   34,   63,   64,   70,   51,   52,   71,   53,
       54,   55,   47,   92,   42,   44,   92,   69,   68,   72,

       74,   70,   73,   92,   60,   71,   92,   61,   76,   92,
       65,   68,   77,   75,   78,   79,   72,   74,   73,   80,
       81,   82,   44,   83,   76,   84,   56,   85,   86,   77,
       78,   87,   79,   88,   44,   80,   81,   89,   82,   83,
       90,   91,   84,   85,   86,   92,   28,   87,   92,   92,
       88,   92,   92,   89,   92,   92,   90,   91,   29,   29,
       29,   29,   29,   29,   29,   31,   31,   31,   31,   31,
       31,   31,   35,   35,   35,   35,   35,   35,   35,   39,
       92,   39,   39,   39,   39,   39,   48,   48,   57,   92,
       57,   57,   57,   57,   57,   58,   92,   58,   92,   58,

       58,   58,   59,   92,   59,   59,   59,   59,   59,   62,
       62,   92,   62,   62,   62,   62,   66,   92,   66,   66,
       66,   66,   67,   92,   67,   67,   67,   67,   67,    9,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92
    } ;

static  flex_int16_t aag_chk[279] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    3,    4,
        7,    3,    4,    5,    5,    6,    6,    8,    7,    7,
       17,   22,   18,   17,   18,    8,    8,   15,   15,   23,
       15,   24,   15,   25,   26,   26,   30,   22,   98,   30,
        5,   50,    6,   34,   34,   51,   23,   24,   52,   25,
       26,   26,   42,   44,   42,   44,   47,   50,   47,   53,

       55,   51,   54,   59,   60,   52,   59,   60,   69,   68,
       34,   68,   70,   56,   71,   72,   53,   55,   54,   73,
       74,   76,   41,   78,   69,   80,   27,   81,   82,   70,
       71,   84,   72,   85,   16,   73,   74,   86,   76,   78,
       88,   90,   80,   81,   82,    9,    2,   84,    0,    0,
       85,    0,    0,   86,    0,    0,   88,   90,   93,   93,
       93,   93,   93,   93,   93,   94,   94,   94,   94,   94,
       94,   94,   95,   95,   95,   95,   95,   95,   95,   96,
        0,   96,   96,   96,   96,   96,   97,   97,   99,    0,
       99,   99,   99,   99,   99,  100,    0,  100,    0,  100,

      100,  100,  101,    0,  101,  101,  101,  101,  101,  102,
      102,    0,  102,  102,  102,  102,  103,    0,  103,  103,
      103,  103,  104,    0,  104,  104,  104,  104,  104,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92
    } ;

static aag_state_type aag_last_accepting_state;
static char *aag_last_accepting_cpos;

extern int aag_flex_debug;
int aag_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */




char *aagtext;

/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */
/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/
/* requires flex (i.e. not lex)  */

#line 1 "graphviz-2.38.0\\lib\\cgraph\\grammar.h" 1
/* A Bison parser, made by GNU Bison 2.6.1.  */

/* Bison interface for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */



/* Enabling traces.  */







/* Tokens.  */


   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum aagtokentype {
     T_graph = 258,
     T_node = 259,
     T_edge = 260,
     T_digraph = 261,
     T_subgraph = 262,
     T_strict = 263,
     T_edgeop = 264,
     T_list = 265,
     T_attr = 266,
     T_atom = 267,
     T_qatom = 268
   };

/* Tokens.  */















typedef union YYSTYPE
{
/* Line 2049 of yacc.c  */


			int				i;
			char			*str;
			struct Agnode_s	*n;


/* Line 2049 of yacc.c  */

} YYSTYPE;





extern YYSTYPE aaglval;











int aagparse ();




#line 462 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 2
#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1
/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */

/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/










#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1


#line 1 "graphviz-2.38.0\\lib\\cgraph\\cgraph.h" 1
/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */

/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/




#line 1 "graphviz-2.38.0\\lib\\cdt\\cdt.h" 1



/*	Public interface for the dictionary library
**
**      Written by Kiem-Phong Vo
*/











#line 1 "graphviz-2.38.0\\lib\\cdt\\cdt.h" 1
#line 1 "graphviz-2.38.0\\lib\\cdt\\cdt.h" 1






















typedef struct _dtlink_s	Dtlink_t;
typedef struct _dthold_s	Dthold_t;
typedef struct _dtdisc_s	Dtdisc_t;
typedef struct _dtmethod_s	Dtmethod_t;
typedef struct _dtdata_s	Dtdata_t;
typedef struct _dt_s		Dt_t;
typedef struct _dt_s		Dict_t;	/* for libdict compatibility */
typedef struct _dtstat_s	Dtstat_t;
typedef void*			(*Dtmemory_f)(Dt_t*,void*,size_t,Dtdisc_t*);
typedef void*			(*Dtsearch_f)(Dt_t*,void*,int);
typedef void* 		(*Dtmake_f)(Dt_t*,void*,Dtdisc_t*);
typedef void 			(*Dtfree_f)(Dt_t*,void*,Dtdisc_t*);
typedef int			(*Dtcompar_f)(Dt_t*,void*,void*,Dtdisc_t*);
typedef unsigned int		(*Dthash_f)(Dt_t*,void*,Dtdisc_t*);
typedef int			(*Dtevent_f)(Dt_t*,int,void*,Dtdisc_t*);

struct _dtlink_s
{	Dtlink_t*	right;	/* right child		*/
	union
	{ unsigned int	_hash;	/* hash value		*/
	  Dtlink_t*	_left;	/* left child		*/
	} hl;
};

/* private structure to hold an object */
struct _dthold_s
{	Dtlink_t	hdr;	/* header		*/
	void*		obj;	/* user object		*/
};

/* method to manipulate dictionary structure */
struct _dtmethod_s 
{	Dtsearch_f	searchf; /* search function	*/
	int		type;	/* type of operation	*/
};

/* stuff that may be in shared memory */
struct _dtdata_s
{	int		type;	/* type of dictionary			*/
	Dtlink_t*	here;	/* finger to last search element	*/
	union
	{ Dtlink_t**	_htab;	/* hash table				*/
	  Dtlink_t*	_head;	/* linked list				*/
	} hh;
	int		ntab;	/* number of hash slots			*/
	int		size;	/* number of objects			*/
	int		loop;	/* number of nested loops		*/
	int		minp;	/* min path before splay, always even	*/
				/* for hash dt, > 0: fixed table size 	*/
};

/* structure to hold methods that manipulate an object */
struct _dtdisc_s
{	int		key;	/* where the key begins in an object	*/
	int		size;	/* key size and type			*/
	int		link;	/* offset to Dtlink_t field		*/
	Dtmake_f	makef;	/* object constructor			*/
	Dtfree_f	freef;	/* object destructor			*/
	Dtcompar_f	comparf;/* to compare two objects		*/
	Dthash_f	hashf;	/* to compute hash value of an object	*/
	Dtmemory_f	memoryf;/* to allocate/free memory		*/
	Dtevent_f	eventf;	/* to process events			*/
};













/* the dictionary structure itself */
struct _dt_s
{	Dtsearch_f	searchf;/* search function			*/
	Dtdisc_t*	disc;	/* method to manipulate objs		*/
	Dtdata_t*	data;	/* sharable data			*/
	Dtmemory_f	memoryf;/* function to alloc/free memory	*/
	Dtmethod_t*	meth;	/* dictionary method			*/
	int		type;	/* type information			*/
	int		nview;	/* number of parent view dictionaries	*/
	Dt_t*		view;	/* next on viewpath			*/
	Dt_t*		walk;	/* dictionary being walked		*/
	void*		user;	/* for user's usage			*/
};

/* structure to get status of a dictionary */
struct _dtstat_s
{	int	dt_meth;	/* method type				*/
	int	dt_size;	/* number of elements			*/
	int	dt_n;		/* number of chains or levels		*/
	int	dt_max;		/* max size of a chain or a level	*/
	int*	dt_count;	/* counts of chains or levels by size	*/
};

/* flag set if the last search operation actually found the object */


/* supported storage methods */










/* asserts to dtdisc() */



/* types of search */















/* events */








1	/* public data */







extern Dtmethod_t* 	Dtset;
extern Dtmethod_t* 	Dtbag;
extern Dtmethod_t* 	Dtoset;
extern Dtmethod_t* 	Dtobag;
extern Dtmethod_t*	Dtlist;
extern Dtmethod_t*	Dtstack;
extern Dtmethod_t*	Dtqueue;
extern Dtmethod_t*	Dtdeque;

/* compatibility stuff; will go away */

extern Dtmethod_t*	Dtorder;
extern Dtmethod_t*	Dttree;
extern Dtmethod_t*	Dthash;
extern Dtmethod_t	_Dttree;
extern Dtmethod_t	_Dthash;
extern Dtmethod_t	_Dtlist;
extern Dtmethod_t	_Dtqueue;
extern Dtmethod_t	_Dtstack;





1	/* public functions */




extern Dt_t*		dtopen (Dtdisc_t*, Dtmethod_t*);
extern int		dtclose (Dt_t*);
extern Dt_t*		dtview (Dt_t*, Dt_t*);
extern Dtdisc_t*	dtdisc (Dt_t* dt, Dtdisc_t*, int);
extern Dtmethod_t*	dtmethod (Dt_t*, Dtmethod_t*);

extern Dtlink_t*	dtflatten (Dt_t*);
extern Dtlink_t*	dtextract (Dt_t*);
extern int		dtrestore (Dt_t*, Dtlink_t*);

extern int		dttreeset (Dt_t*, int, int);

extern int		dtwalk (Dt_t*, int(*)(Dt_t*,void*,void*), void*);

extern void*		dtrenew (Dt_t*, void*);

extern int		dtsize (Dt_t*);
extern int		dtstat (Dt_t*, Dtstat_t*, int);
extern unsigned int	dtstrhash (unsigned int, void*, int);











/* internal functions for translating among holder, object and key */












/* special search function for tree structure only */

























































#line 17 "graphviz-2.38.0\\lib\\cgraph\\cgraph.h" 2
























/* forward struct type declarations */
typedef struct Agtag_s Agtag_t;
typedef struct Agobj_s Agobj_t;	/* generic object header */
typedef struct Agraph_s Agraph_t;	/* graph, subgraph (or hyperedge) */
typedef struct Agnode_s Agnode_t;	/* node (atom) */
typedef struct Agedge_s Agedge_t;	/* node pair */
typedef struct Agdesc_s Agdesc_t;	/* graph descriptor */
typedef struct Agmemdisc_s Agmemdisc_t;	/* memory allocator */
typedef struct Agiddisc_s Agiddisc_t;	/* object ID allocator */
typedef struct Agiodisc_s Agiodisc_t;	/* IO services */
typedef struct Agdisc_s Agdisc_t;	/* union of client discipline methods */
typedef struct Agdstate_s Agdstate_t;	/* client state (closures) */
typedef struct Agsym_s Agsym_t;	/* string attribute descriptors */
typedef struct Agattr_s Agattr_t;	/* string attribute container */
typedef struct Agcbdisc_s Agcbdisc_t;	/* client event callbacks */
typedef struct Agcbstack_s Agcbstack_t;	/* enclosing state for cbdisc */
typedef struct Agclos_s Agclos_t;	/* common fields for graph/subgs */
typedef struct Agrec_s Agrec_t;	/* generic runtime record */
typedef struct Agdatadict_s Agdatadict_t;	/* set of dictionaries per graph */
typedef struct Agedgepair_s Agedgepair_t;	/* the edge object */
typedef struct Agsubnode_s Agsubnode_t;

/* Header of a user record.  These records are attached by client programs
dynamically at runtime.  A unique string ID must be given to each record
attached to the same object.  Cgraph has functions to create, search for,
and delete these records.   The records are maintained in a circular list,
with obj->data pointing somewhere in the list.  The search function has
an option to lock this pointer on a given record.  The application must
be written so only one such lock is outstanding at a time. */

struct Agrec_s {
    char *name;
    Agrec_t *next;
    /* following this would be any programmer-defined data */
};

/* Object tag for graphs, nodes, and edges.  While there may be several structs
for a given node or edges, there is only one unique ID (per main graph).  */
struct Agtag_s {
    unsigned objtype:2;		/* see literal tags below */
    unsigned mtflock:1;		/* move-to-front lock, see above */
    unsigned attrwf:1;		/* attrs written (parity, write.c) */
    unsigned seq:(sizeof(unsigned) * 8 - 4);	/* sequence no. */
    unsigned long id;		/* client  ID */
};

	/* object tags */








	/* a generic graph/node/edge header */
struct Agobj_s {
    Agtag_t tag;
    Agrec_t *data;
};










/* This is the node struct allocated per graph (or subgraph).  It resides
in the n_dict of the graph.  The node set is maintained by libdict, but
transparently to libgraph callers.  Every node may be given an optional
string name at its time of creation, or it is permissible to pass NIL(char*)
for the name. */

struct Agsubnode_s {		/* the node-per-graph-or-subgraph record */
    Dtlink_t seq_link;		/* must be first */
    Dtlink_t id_link;
    Agnode_t *node;		/* the object */
    Dtlink_t *in_id, *out_id;	/* by node/ID for random access */
    Dtlink_t *in_seq, *out_seq;	/* by node/sequence for serial access */
};

struct Agnode_s {
    Agobj_t base;
    Agraph_t *root;
    Agsubnode_t mainsub;	/* embedded for main graph */
};

struct Agedge_s {
    Agobj_t base;
    Dtlink_t id_link;		/* main graph only */
    Dtlink_t seq_link;
    Agnode_t *node;		/* the endpoint node */
};

struct Agedgepair_s {
    Agedge_t out, in;
};

struct Agdesc_s {		/* graph descriptor */
    unsigned directed:1;	/* if edges are asymmetric */
    unsigned strict:1;		/* if multi-edges forbidden */
    unsigned no_loop:1;		/* if no loops */
    unsigned maingraph:1;	/* if this is the top level graph */
    unsigned flatlock:1;	/* if sets are flattened into lists in cdt */
    unsigned no_write:1;	/* if a temporary subgraph */
    unsigned has_attrs:1;	/* if string attr tables should be initialized */
    unsigned has_cmpnd:1;	/* if may contain collapsed nodes */
};

/* disciplines for external resources needed by libgraph */

struct Agmemdisc_s {		/* memory allocator */
    void *(*open) (Agdisc_t*);	/* independent of other resources */
    void *(*alloc) (void *state, size_t req);
    void *(*resize) (void *state, void *ptr, size_t old, size_t req);
    void (*free) (void *state, void *ptr);
    void (*close) (void *state);
};

struct Agiddisc_s {		/* object ID allocator */
    void *(*open) (Agraph_t * g, Agdisc_t*);	/* associated with a graph */
    long (*map) (void *state, int objtype, char *str, unsigned long *id,
		 int createflag);
    long (*alloc) (void *state, int objtype, unsigned long id);
    void (*free) (void *state, int objtype, unsigned long id);
    char *(*print) (void *state, int objtype, unsigned long id);
    void (*close) (void *state);
    void (*idregister) (void *state, int objtype, void *obj);
};

struct Agiodisc_s {
    int (*afread) (void *chan, char *buf, int bufsize);
    int (*putstr) (void *chan, const char *str);
    int (*flush) (void *chan);	/* sync */
    /* error messages? */
};

struct Agdisc_s {		/* user's discipline */
    Agmemdisc_t *mem;
    Agiddisc_t *id;
    Agiodisc_t *io;
};

	/* default resource disciplines */

/*visual studio*/







/*end visual studio*/

extern Agmemdisc_t AgMemDisc;
extern Agiddisc_t AgIdDisc;
extern Agiodisc_t AgIoDisc;

extern Agdisc_t AgDefaultDisc;


struct Agdstate_s {
    void *mem;
    void *id;
    /* IO must be initialized and finalized outside Cgraph,
     * and channels (FILES) are passed as void* arguments. */
};

typedef void (*agobjfn_t) (Agraph_t * g, Agobj_t * obj, void *arg);
typedef void (*agobjupdfn_t) (Agraph_t * g, Agobj_t * obj, void *arg,
			      Agsym_t * sym);

struct Agcbdisc_s {
    struct {
	agobjfn_t ins;
	agobjupdfn_t mod;
	agobjfn_t del;
    } graph, node, edge;
};

struct Agcbstack_s {		/* object event callbacks */
    Agcbdisc_t *f;		/* methods */
    void *state;		/* closure */
    Agcbstack_t *prev;		/* kept in a stack, unlike other disciplines */
};

struct Agclos_s {
    Agdisc_t disc;		/* resource discipline functions */
    Agdstate_t state;		/* resource closures */
    Dict_t *strdict;		/* shared string dict */
    unsigned long seq[3];	/* local object sequence number counter */
    Agcbstack_t *cb;		/* user and system callback function stacks */
    unsigned char callbacks_enabled;	/* issue user callbacks or hold them? */
    Dict_t *lookup_by_name[3];
    Dict_t *lookup_by_id[3];
};

struct Agraph_s {
    Agobj_t base;
    Agdesc_t desc;
    Dtlink_t link;
    Dict_t *n_seq;		/* the node set in sequence */
    Dict_t *n_id;		/* the node set indexed by ID */
    Dict_t *e_seq, *e_id;	/* holders for edge sets */
    Dict_t *g_dict;		/* subgraphs - descendants */
    Agraph_t *parent, *root;	/* subgraphs - ancestors */
    Agclos_t *clos;		/* shared resources */
};












extern void agpushdisc(Agraph_t * g, Agcbdisc_t * disc, void *state);
extern int agpopdisc(Agraph_t * g, Agcbdisc_t * disc);
extern int agcallbacks(Agraph_t * g, int flag);	/* return prev value */

/* graphs */
extern Agraph_t *agopen(char *name, Agdesc_t desc, Agdisc_t * disc);
extern int agclose(Agraph_t * g);
extern Agraph_t *agread(void *chan, Agdisc_t * disc);
extern Agraph_t *agmemread(const char *cp);
extern void agreadline(int);
extern void agsetfile(char *);
extern Agraph_t *agconcat(Agraph_t * g, void *chan, Agdisc_t * disc);
extern int agwrite(Agraph_t * g, void *chan);
extern int agisdirected(Agraph_t * g);
extern int agisundirected(Agraph_t * g);
extern int agisstrict(Agraph_t * g);
extern int agissimple(Agraph_t * g);

/* nodes */
extern Agnode_t *agnode(Agraph_t * g, char *name, int createflag);
extern Agnode_t *agidnode(Agraph_t * g, unsigned long id, int createflag);
extern Agnode_t *agsubnode(Agraph_t * g, Agnode_t * n, int createflag);
extern Agnode_t *agfstnode(Agraph_t * g);
extern Agnode_t *agnxtnode(Agraph_t * g, Agnode_t * n);
extern Agnode_t *aglstnode(Agraph_t * g);
extern Agnode_t *agprvnode(Agraph_t * g, Agnode_t * n);

extern Agsubnode_t *agsubrep(Agraph_t * g, Agnode_t * n);

/* edges */
extern Agedge_t *agedge(Agraph_t * g, Agnode_t * t, Agnode_t * h,
			char *name, int createflag);
extern Agedge_t *agidedge(Agraph_t * g, Agnode_t * t, Agnode_t * h,
			  unsigned long id, int createflag);
extern Agedge_t *agsubedge(Agraph_t * g, Agedge_t * e, int createflag);
extern Agedge_t *agfstin(Agraph_t * g, Agnode_t * n);
extern Agedge_t *agnxtin(Agraph_t * g, Agedge_t * e);
extern Agedge_t *agfstout(Agraph_t * g, Agnode_t * n);
extern Agedge_t *agnxtout(Agraph_t * g, Agedge_t * e);
extern Agedge_t *agfstedge(Agraph_t * g, Agnode_t * n);
extern Agedge_t *agnxtedge(Agraph_t * g, Agedge_t * e, Agnode_t * n);

/* generic */
extern Agraph_t *agraphof(void* obj);
extern Agraph_t *agroot(void* obj);
extern int agcontains(Agraph_t *, void *);
extern char *agnameof(void *);
extern int agrelabel(void *obj, char *name);	/* scary */
extern int agrelabel_node(Agnode_t * n, char *newname);
extern int agdelete(Agraph_t * g, void *obj);
extern long agdelsubg(Agraph_t * g, Agraph_t * sub);	/* could be agclose */
extern int agdelnode(Agraph_t * g, Agnode_t * arg_n);
extern int agdeledge(Agraph_t * g, Agedge_t * arg_e);
extern int agobjkind(void *);

/* strings */
extern char *agstrdup(Agraph_t *, char *);
extern char *agstrdup_html(Agraph_t *, char *);
extern int aghtmlstr(char *);
extern char *agstrbind(Agraph_t * g, char *);
extern int agstrfree(Agraph_t *, char *);
extern char *agcanon(char *, int);
extern char *agstrcanon(char *, char *);
extern char *agcanonStr(char *str);  /* manages its own buf */

/* definitions for dynamic string attributes */
struct Agattr_s {		/* dynamic string attributes */
    Agrec_t h;			/* common data header */
    Dict_t *dict;		/* shared dict to interpret attr field */
    char **str;			/* the attribute string values */
};

struct Agsym_s {		/* symbol in one of the above dictionaries */
    Dtlink_t link;
    char *name;			/* attribute's name */
    char *defval;		/* its default value for initialization */
    int id;			/* its index in attr[] */
    unsigned char kind;		/* referent object type */
    unsigned char fixed;	/* immutable value */
    unsigned char print;	/* always print */
};

struct Agdatadict_s {		/* set of dictionaries per graph */
    Agrec_t h;			/* installed in list of graph recs */
    struct {
	Dict_t *n, *e, *g;
    } dict;
};

extern Agsym_t *agattr(Agraph_t * g, int kind, char *name, char *value);
extern Agsym_t *agattrsym(void *obj, char *name);
extern Agsym_t *agnxtattr(Agraph_t * g, int kind, Agsym_t * attr);
extern int      agcopyattr(void *oldobj, void *newobj);

extern void *agbindrec(void *obj, char *name, unsigned int size,
		       int move_to_front);
extern Agrec_t *aggetrec(void *obj, char *name, int move_to_front);
extern int agdelrec(void *obj, char *name);
extern void aginit(Agraph_t * g, int kind, char *rec_name, int rec_size,
		   int move_to_front);
extern void agclean(Agraph_t * g, int kind, char *rec_name);

extern char *agget(void *obj, char *name);
extern char *agxget(void *obj, Agsym_t * sym);
extern int agset(void *obj, char *name, char *value);
extern int agxset(void *obj, Agsym_t * sym, char *value);
extern int agsafeset(void* obj, char* name, char* value, char* def);

/* defintions for subgraphs */
extern Agraph_t *agsubg(Agraph_t * g, char *name, int cflag);	/* constructor */
extern Agraph_t *agidsubg(Agraph_t * g, unsigned long id, int cflag);	/* constructor */
extern Agraph_t *agfstsubg(Agraph_t * g), *agnxtsubg(Agraph_t * subg);
extern Agraph_t *agparent(Agraph_t * g);

/* set cardinality */
extern int agnnodes(Agraph_t * g), agnedges(Agraph_t * g), agnsubg(Agraph_t * g);
extern int agdegree(Agraph_t * g, Agnode_t * n, int in, int out);
extern int agcountuniqedges(Agraph_t * g, Agnode_t * n, int in, int out);

/* memory */
extern void *agalloc(Agraph_t * g, size_t size);
extern void *agrealloc(Agraph_t * g, void *ptr, size_t oldsize,
		       size_t size);
extern void agfree(Agraph_t * g, void *ptr);
extern struct _vmalloc_s *agheap(Agraph_t * g);

/* an engineering compromise is a joy forever */
extern void aginternalmapclearlocalnames(Agraph_t * g);




/* error handling */
typedef enum { AGWARN, AGERR, AGMAX, AGPREV } agerrlevel_t;
typedef int (*agusererrf) (char*);
extern agerrlevel_t agseterr(agerrlevel_t);
extern char *aglasterr(void);
extern int agerr(agerrlevel_t level, const char *fmt, ...);
extern void agerrorf(const char *fmt, ...);
extern void agwarningf(const char *fmt, ...);
extern int agerrors(void);
extern int agreseterrors(void);
extern agusererrf agseterrf(agusererrf);

/* data access macros */
/* this assumes that e[0] is out and e[1] is inedge, see edgepair in edge.c  */


























extern Agdesc_t Agdirected, Agstrictdirected, Agundirected,
    Agstrictundirected;



/* fast graphs */
void agflatten(Agraph_t * g, int flag);
typedef Agsubnode_t	Agnoderef_t;
typedef Dtlink_t	Agedgeref_t;


































#line 20 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 2

#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1








#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1
#line 1 "graphviz-2.38.0\\lib\\cgraph\\cghdr.h" 1













































	/* functional definitions */
typedef Agobj_t *(*agobjsearchfn_t) (Agraph_t * g, Agobj_t * obj);
int agapply(Agraph_t * g, Agobj_t * obj, agobjfn_t fn, void *arg,
	    int preorder);

	/* global variables */
extern Agraph_t *Ag_G_global;
extern char *AgDataRecName;

	/* set ordering disciplines */
extern Dtdisc_t Ag_subnode_id_disc;
extern Dtdisc_t Ag_subnode_seq_disc;
extern Dtdisc_t Ag_mainedge_id_disc;
extern Dtdisc_t Ag_subedge_id_disc;
extern Dtdisc_t Ag_mainedge_seq_disc;
extern Dtdisc_t Ag_subedge_seq_disc;
extern Dtdisc_t Ag_subgraph_id_disc;
extern Agcbdisc_t AgAttrdisc;

	/* internal constructor of graphs and subgraphs */
Agraph_t *agopen1(Agraph_t * g);
int agstrclose(Agraph_t * g);

	/* ref string management */
void agmarkhtmlstr(char *s);

	/* object set management */
Agnode_t *agfindnode_by_id(Agraph_t * g, unsigned long id);
Dtcompar_f agdictorder(Agraph_t *, Dict_t *, Dtcompar_f);
int agedgecmpf(Dict_t * d, void *arg_e0, void *arg_e1, Dtdisc_t * disc);
int agnamecmpf(Dict_t * d, void *, void *, Dtdisc_t * disc);
void agset_node_disc(Agraph_t * g, Dtdisc_t * disc);
unsigned long agnextseq(Agraph_t * g, int objtype);

/* dict helper functions */
Dict_t *agdtopen(Agraph_t * g, Dtdisc_t * disc, Dtmethod_t * method);
void agdtdisc(Agraph_t * g, Dict_t * dict, Dtdisc_t * disc);
long agdtdelete(Agraph_t * g, Dict_t * dict, void *obj);
int agdtclose(Agraph_t * g, Dict_t * dict);
void *agdictobjmem(Dict_t * dict, void * p, size_t size,
		   Dtdisc_t * disc);
void agdictobjfree(Dict_t * dict, void * p, Dtdisc_t * disc);

	/* name-value pair operations */
Agdatadict_t *agdatadict(Agraph_t * g, int cflag);
Agattr_t *agattrrec(void *obj);

void agraphattr_init(Agraph_t * g);
int agraphattr_delete(Agraph_t * g);
void agnodeattr_init(Agraph_t *g, Agnode_t * n);
void agnodeattr_delete(Agnode_t * n);
void agedgeattr_init(Agraph_t *g, Agedge_t * e);
void agedgeattr_delete(Agedge_t * e);

	/* parsing and lexing graph files */
int aagparse(void);
void aglexinit(Agdisc_t * disc, void *ifile);
int aaglex(void);
void aglexeof(void);
void aglexbad(void);

	/* ID management */
int agmapnametoid(Agraph_t * g, int objtype, char *str,
		  unsigned long *result, int allocflag);
int agallocid(Agraph_t * g, int objtype, unsigned long request);
void agfreeid(Agraph_t * g, int objtype, unsigned long id);
char *agprintid(Agobj_t * obj);
int aginternalmaplookup(Agraph_t * g, int objtype, char *str,
			unsigned long *result);
void aginternalmapinsert(Agraph_t * g, int objtype, char *str,
			 unsigned long result);
char *aginternalmapprint(Agraph_t * g, int objtype, unsigned long id);
int aginternalmapdelete(Agraph_t * g, int objtype, unsigned long id);
void aginternalmapclose(Agraph_t * g);
void agregister(Agraph_t * g, int objtype, void *obj);

	/* internal set operations */
void agedgesetop(Agraph_t * g, Agedge_t * e, int insertion);
void agdelnodeimage(Agraph_t * g, Agnode_t * node, void *ignored);
void agdeledgeimage(Agraph_t * g, Agedge_t * edge, void *ignored);
void *agrebind0(Agraph_t * g, void *obj);	/* unsafe */
int agrename(Agobj_t * obj, char *newname);
void agrecclose(Agobj_t * obj);

void agmethod_init(Agraph_t * g, void *obj);
void agmethod_upd(Agraph_t * g, void *obj, Agsym_t * sym);
void agmethod_delete(Agraph_t * g, void *obj);




void agsyspushdisc(Agraph_t * g, Agcbdisc_t * cb, void *state, int stack);
int agsyspopdisc(Agraph_t * g, Agcbdisc_t * cb, int stack);
void agrecord_callback(Agraph_t * g, Agobj_t * obj, int kind,
		       Agsym_t * optsym);
void aginitcb(Agraph_t * g, void *obj, Agcbstack_t * disc);
void agupdcb(Agraph_t * g, void *obj, Agsym_t * sym, Agcbstack_t * disc);
void agdelcb(Agraph_t * g, void *obj, Agcbstack_t * disc);


#line 463 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 2
#line 1 "graphviz-2.38.0\\lib\\cgraph\\agxbuf.h" 1
/* $Id$ $Revision$ */
/* vim:set shiftwidth=4 ts=8: */

/*************************************************************************
 * Copyright (c) 2011 AT&T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************/








/* Extensible buffer:
 *  Malloc'ed memory is never released until agxbfree is called.
 */
    typedef struct {
	unsigned char *buf;	/* start of buffer */
	unsigned char *ptr;	/* next place to write */
	unsigned char *eptr;	/* end of buffer */
	int dyna;		/* true if buffer is malloc'ed */
    } agxbuf;

/* agxbinit:
 * Initializes new agxbuf; caller provides memory.
 * Assume if init is non-null, hint = sizeof(init[])
 */
    extern void agxbinit(agxbuf * xb, unsigned int hint,
			 unsigned char *init);

/* agxbput_n:
 * Append string s of length n into xb
 */
    extern int agxbput_n(agxbuf * xb, const char *s, unsigned int n);

/* agxbput:
 * Append string s into xb
 */
    extern int agxbput(agxbuf * xb, const char *s);

/* agxbfree:
 * Free any malloced resources.
 */
    extern void agxbfree(agxbuf * xb);

/* agxbpop:
 * Removes last character added, if any.
 */
    extern int agxbpop(agxbuf * xb);

/* agxbmore:
 * Expand buffer to hold at least ssz more bytes.
 */
    extern int agxbmore(agxbuf * xb, int unsigned ssz);

/* agxbputc:
 * Add character to buffer.
 *  int agxbputc(agxbuf*, char)
 */



/* agxbuse:
 * Null-terminates buffer; resets and returns pointer to data;
 *  char* agxbuse(agxbuf* xb)
 */


/* agxbstart:
 * Return pointer to beginning of buffer.
 *  char* agxbstart(agxbuf* xb)
 */


/* agxblen:
 * Return number of characters currently stored.
 *  int agxblen(agxbuf* xb)
 */


/* agxbclear:
 * Resets pointer to data;
 *  void agxbclear(agxbuf* xb)
 */


/* agxbnext:
 * Next position for writing.
 *  char* agxbnext(agxbuf* xb)
 */







#line 464 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 2
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1

	/* this is a workaround for linux flex */
static int line_num = 1;
static int html_nest = 0;  /* nesting level for html strings */
static char* InputFile;
static Agdisc_t	*Disc;
static void 	*Ifile;
static int graphType;

  /* Reset line number */
void agreadline(int n) { line_num = n; }

  /* (Re)set file:
   */
void agsetfile(char* f) { InputFile = f; line_num = 1; }

/* There is a hole here, because switching channels 
 * requires pushing back whatever was previously read.
 * There probably is a right way of doing this.
 */
void aglexinit(Agdisc_t *disc, void *ifile) { Disc = disc; Ifile = ifile; graphType = 0;}








/* buffer for arbitrary length strings (longer than BUFSIZ) */
static char	*Sbuf,*Sptr,*Send;
static void beginstr(void) {
	if (Sbuf == ((char*)0)) {
		Sbuf = malloc(BUFSIZ);
		Send = Sbuf + BUFSIZ;
	}
	Sptr = Sbuf;
	*Sptr = 0;
}

static void addstr(char *src) {
	char	c;
	if (Sptr > Sbuf) Sptr--;
	do {
		do {c = *Sptr++ = *src++;} while (c && (Sptr < Send));
		if (c) {
			long	sz = Send - Sbuf;
			long	off = Sptr - Sbuf;
			sz *= 2;
			Sbuf = (char*)realloc(Sbuf,sz);
			Send = Sbuf + sz;
			Sptr = Sbuf + off;
		}
	} while (c);
}

static void endstr(void) {
	aaglval.str = (char*)agstrdup(Ag_G_global,Sbuf);
}

static void endstr_html(void) {
	aaglval.str = (char*)agstrdup_html(Ag_G_global,Sbuf);
}

static void
storeFileName (char* fname, int len)
{
    static int cnt;
    static char* buf;

    if (len > cnt) {
	if (cnt) buf = (char*)realloc (buf, len+1);
	else buf = (char*)malloc (len+1);
	cnt = len;
    }
    strcpy (buf, fname);
    InputFile = buf;
}

/* ppDirective:
 * Process a possible preprocessor line directive.
 * aagtext = #.*
 */
static void ppDirective (void)
{
    int r, cnt, lineno;
    char buf[2];
    char* s = aagtext + 1;  /* skip initial # */

    if (strncmp(s, "line", 4) == 0) s += 4;
    r = sscanf(s, "%d %1[\"]%n", &lineno, buf, &cnt);
    if (r > 0) { /* got line number */ 
	line_num = lineno - 1;
	if (r > 1) { /* saw quote */
	    char* p = s + cnt;
	    char* e = p;
	    while (*e && (*e != '"')) e++; 
	    if (e != p) {
 		*e = '\0';
		storeFileName (p, e-p);
	    }
	}
    }
}

/* chkNum:
 * The regexp for NUMBER allows a terminating letter.
 * This way we can catch a number immediately followed by a name
 * and report this to the user.
 */
static int chkNum(void) {
    unsigned char c = (unsigned char)aagtext[aagleng-1];   /* last character */
    if (!isdigit(c) && (c != '.')) {  /* c is letter */
	unsigned char xbuf[BUFSIZ];
	char buf[BUFSIZ];
	agxbuf  xb;
	char* fname;

	if (InputFile)
	    fname = InputFile;
	else
	    fname = "input";

	agxbinit(&xb, BUFSIZ, xbuf);

	agxbput(&xb,"syntax ambiguity - badly delimited number '");
	agxbput(&xb,aagtext);
	sprintf(buf,"' in line %d of ", line_num);
	agxbput(&xb,buf);
	agxbput(&xb,fname);
	agxbput(&xb, " splits into two tokens\n");
	agerr(AGWARN,(((((&xb)->ptr >= (&xb)->eptr) ? agxbmore(&xb,1) : 0), (int)(*(&xb)->ptr++ = ((unsigned char)'\0'))),(char*)((&xb)->ptr = (&xb)->buf)));

	agxbfree(&xb);
	return 1;
    }
    else return 0;
}

/* The LETTER class below consists of ascii letters, underscore, all non-ascii
 * characters. This allows identifiers to have characters from any
 * character set independent of locale. The downside is that, for certain
 * character sets, non-letter and, in fact, undefined characters will be
 * accepted. This is not likely and, from dot's stand, shouldn't do any
 * harm. (Presumably undefined characters will be ignored in display.) And,
 * it allows a greater wealth of names. */











/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#line 1 "graphviz-2.38.0\\lib\\cgraph\\scan.c" 1






static int aag_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int aaglex_destroy (void );

int aagget_debug (void );

void aagset_debug (int debug_flag  );

void * aagget_extra (void );

void aagset_extra (void * user_defined  );

FILE *aagget_in (void );

void aagset_in  (FILE * in_str  );

FILE *aagget_out (void );

void aagset_out  (FILE * out_str  );

aag_size_t aagget_leng (void );

char *aagget_text (void );

int aagget_lineno (void );

void aagset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */





extern int aagwrap (void );



    static void aagunput (int c,char *buf_ptr  );
    













static int input (void );




/* Amount of stuff to slurp up with each read. */




/* Copy whatever the last rule matched to the standard output. */

/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */



/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */

































/* No semi-colon after return; correct usage is to write "aagterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */




/* Number of entries by which start-condition stack grows. */




/* Report a fatal error. */




/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */



extern int aaglex (void);




/* Code executed at the beginning of each rule, after aagtext and aagleng
 * have been set up.
 */




/* Code executed at the end of each rule. */










/** The main scanner function which does all the work.
 */
int aaglex (void)
{
	register aag_state_type aag_current_state;
	register char *aag_cp, *aag_bp;
	register int aag_act;
    




	if ( !(aag_init) )
		{
		(aag_init) = 1;


		


		if ( ! (aag_start) )
			(aag_start) = 1;	/* first start state */

		if ( ! aagin )
			aagin = stdin;

		if ( ! aagout )
			aagout = stdout;

		if ( ! ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) ) {
			aagensure_buffer_stack ();
			(aag_buffer_stack)[(aag_buffer_stack_top)] =
				aag_create_buffer(aagin,16384 );
		}

		aag_load_buffer_state( );
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		aag_cp = (aag_c_buf_p);

		/* Support of aagtext. */
		*aag_cp = (aag_hold_char);

		/* aag_bp points to the position in aag_ch_buf of the start of
		 * the current run.
		 */
		aag_bp = aag_cp;

		aag_current_state = (aag_start);
		aag_current_state += ((aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol);
aag_match:
		do
			{
			register YY_CHAR aag_c = aag_ec[((unsigned int) (unsigned char) *aag_cp)];
			if ( aag_accept[aag_current_state] )
				{
				(aag_last_accepting_state) = aag_current_state;
				(aag_last_accepting_cpos) = aag_cp;
				}
			while ( aag_chk[aag_base[aag_current_state] + aag_c] != aag_current_state )
				{
				aag_current_state = (int) aag_def[aag_current_state];
				if ( aag_current_state >= 93 )
					aag_c = aag_meta[(unsigned int) aag_c];
				}
			aag_current_state = aag_nxt[aag_base[aag_current_state] + (unsigned int) aag_c];
			++aag_cp;
			}
		while ( aag_base[aag_current_state] != 230 );

aag_find_action:
		aag_act = aag_accept[aag_current_state];
		if ( aag_act == 0 )
			{ /* have to back up */
			aag_cp = (aag_last_accepting_cpos);
			aag_current_state = (aag_last_accepting_state);
			aag_act = aag_accept[aag_current_state];
			}

		(aagtext) = aag_bp; aagleng = (size_t) (aag_cp - aag_bp); (aag_hold_char) = *aag_cp; *aag_cp = '\0'; (aag_c_buf_p) = aag_cp;;

do_action:	/* This label is used only to access EOF actions. */

		switch ( aag_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*aag_cp = (aag_hold_char);
			aag_cp = (aag_last_accepting_cpos);
			aag_current_state = (aag_last_accepting_state);
			goto aag_find_action;

case 1:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return(EOF);
	break;
case 2:
/* rule 2 can match eol */
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

line_num++;
	break;
case 3:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

(aag_start) = 1 + 2 *(1);
	break;
case 4:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* eat anything not a '*' */
	break;
case 5:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* eat up '*'s not followed by '/'s */
	break;
case 6:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

(aag_start) = 1 + 2 *(0);
	break;
case 7:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* ignore C++-style comments */
	break;
case 8:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

ppDirective ();
	break;
case 9:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* ignore shell-like comments */
	break;
case 10:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* ignore whitespace */
	break;
case 11:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

/* ignore BOM */
	break;
case 12:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return(259);			/* see tokens in agcanonstr */
	break;
case 13:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return(260);
	break;
case 14:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

if (!graphType) graphType = 258; return(258);
	break;
case 15:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

if (!graphType) graphType = 261; return(261);
	break;
case 16:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return(263);
	break;
case 17:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return(262);
	break;
case 18:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

if (graphType == 261) return(264); else return('-');
	break;
case 19:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

if (graphType == 258) return(264); else return('-');
	break;
case 20:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

{ aaglval.str = (char*)agstrdup(Ag_G_global,aagtext); return(267); }
	break;
case 21:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

{ if (chkNum()) do { int aagless_macro_arg = (aagleng-1); ; *aag_cp = (aag_hold_char);  (aag_c_buf_p) = aag_cp = aag_bp + aagless_macro_arg - 0; (aagtext) = aag_bp; aagleng = (size_t) (aag_cp - aag_bp); (aag_hold_char) = *aag_cp; *aag_cp = '\0'; (aag_c_buf_p) = aag_cp;; } while ( 0 ); aaglval.str = (char*)agstrdup(Ag_G_global,aagtext); return(267); }
	break;
case 22:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

(aag_start) = 1 + 2 *(2); beginstr();
	break;
case 23:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

(aag_start) = 1 + 2 *(0); endstr(); return (268);
	break;
case 24:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

addstr ("\"");
	break;
case 25:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

addstr ("\\\\");
	break;
case 26:
/* rule 26 can match eol */
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

line_num++; /* ignore escaped newlines */
	break;
case 27:
/* rule 27 can match eol */
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

addstr(aagtext);
	break;
case 28:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

(aag_start) = 1 + 2 *(3); html_nest = 1; beginstr();
	break;
case 29:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

html_nest--; if (html_nest) addstr(aagtext); else {(aag_start) = 1 + 2 *(0); endstr_html(); return (268);}
	break;
case 30:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

html_nest++; addstr(aagtext);
	break;
case 31:
/* rule 31 can match eol */
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

addstr(aagtext); line_num++; /* add newlines */
	break;
case 32:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

addstr(aagtext);
	break;
case 33:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

return (aagtext[0]);
	break;
case 34:
if ( aagleng > 0 ) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (aagtext[aagleng - 1] == '\n'); 

do { if (fwrite( aagtext, aagleng, 1, aagout )) {} } while (0);
	break;

case (35 + 0 + 1):
case (35 + 1 + 1):
case (35 + 2 + 1):
case (35 + 3 + 1):
	return 0;

	case 35:
		{
		/* Amount of text matched not including the EOB char. */
		int aag_amount_of_matched_text = (int) (aag_cp - (aagtext)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*aag_cp = (aag_hold_char);
		

		if ( (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buffer_status == 0 )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed aagin at a new source and called
			 * aaglex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(aag_n_chars) = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars;
			(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_input_file = aagin;
			(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buffer_status = 1;
			}

		/* Note that here we test for aag_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since aag_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (aag_c_buf_p) <= &(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars)] )
			{ /* This was really a NUL. */
			aag_state_type aag_next_state;

			(aag_c_buf_p) = (aagtext) + aag_amount_of_matched_text;

			aag_current_state = aag_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * aag_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			aag_next_state = aag_try_NUL_trans( aag_current_state );

			aag_bp = (aagtext) + 0;

			if ( aag_next_state )
				{
				/* Consume the NUL. */
				aag_cp = ++(aag_c_buf_p);
				aag_current_state = aag_next_state;
				goto aag_match;
				}

			else
				{
				aag_cp = (aag_c_buf_p);
				goto aag_find_action;
				}
			}

		else switch ( aag_get_next_buffer(  ) )
			{
			case 1:
				{
				(aag_did_buffer_switch_on_eof) = 0;

				if ( aagwrap( ) )
					{
					/* Note: because we've taken care in
					 * aag_get_next_buffer() to have set up
					 * aagtext, we can now set up
					 * aag_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(aag_c_buf_p) = (aagtext) + 0;

					aag_act = (35 + (((aag_start) - 1) / 2) + 1);
					goto do_action;
					}

				else
					{
					if ( ! (aag_did_buffer_switch_on_eof) )
						aagrestart(aagin );
					}
				break;
				}

			case 0:
				(aag_c_buf_p) =
					(aagtext) + aag_amount_of_matched_text;

				aag_current_state = aag_get_previous_state(  );

				aag_cp = (aag_c_buf_p);
				aag_bp = (aagtext) + 0;
				goto aag_match;

			case 2:
				(aag_c_buf_p) =
				&(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars)];

				aag_current_state = aag_get_previous_state(  );

				aag_cp = (aag_c_buf_p);
				aag_bp = (aagtext) + 0;
				goto aag_find_action;
			}
		break;
		}

	default:
		aag_fatal_error( 
 "fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of aaglex */

/* aag_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int aag_get_next_buffer (void)
{
    	register char *dest = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf;
	register char *source = (aagtext);
	register int number_to_move, i;
	int ret_val;

	if ( (aag_c_buf_p) > &(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars) + 1] )
		aag_fatal_error( 
 "fatal flex scanner internal error--end of buffer missed" );

	if ( (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (aag_c_buf_p) - (aagtext) - 0 == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return 1;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return 2;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((aag_c_buf_p) - (aagtext)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buffer_status == 2 )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars = (aag_n_chars) = 0;

	else
		{
			aag_size_t num_to_read =
			(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = (aag_buffer_stack)[(aag_buffer_stack_top)];

			int aag_c_buf_p_offset =
				(int) ((aag_c_buf_p) - b->aag_ch_buf);

			if ( b->aag_is_our_buffer )
				{
				aag_size_t new_size = b->aag_buf_size * 2;

				if ( new_size <= 0 )
					b->aag_buf_size += b->aag_buf_size / 8;
				else
					b->aag_buf_size *= 2;

				b->aag_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					aagrealloc((void *) b->aag_ch_buf,b->aag_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->aag_ch_buf = 0;

			if ( ! b->aag_ch_buf )
				aag_fatal_error( 
 "fatal error - scanner input buffer overflow" );

			(aag_c_buf_p) = &b->aag_ch_buf[aag_c_buf_p_offset];

			num_to_read = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > 8192 )
			num_to_read = 8192;

		/* Read in more data. */
		if ((
(aag_n_chars) = Disc->io->afread(Ifile, (&(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[number_to_move]), num_to_read)) < 0) aag_fatal_error( "input in flex scanner failed" );

		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars = (aag_n_chars);
		}

	if ( (aag_n_chars) == 0 )
		{
		if ( number_to_move == 0 )
			{
			ret_val = 1;
			aagrestart(aagin  );
			}

		else
			{
			ret_val = 2;
			(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buffer_status =
				2;
			}
		}

	else
		ret_val = 0;

	if ((aag_size_t) ((aag_n_chars) + number_to_move) > (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		aag_size_t new_size = (aag_n_chars) + number_to_move + ((aag_n_chars) >> 1);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf = (char *) aagrealloc((void *) (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf,new_size  );
		if ( ! (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf )
			aag_fatal_error( "out of dynamic memory in aag_get_next_buffer()" );
	}

	(aag_n_chars) += number_to_move;
	(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars)] = 0;
	(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars) + 1] = 0;

	(aagtext) = &(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[0];

	return ret_val;
}

/* aag_get_previous_state - get the state just before the EOB char was reached */

    static aag_state_type aag_get_previous_state (void)
{
	register aag_state_type aag_current_state;
	register char *aag_cp;
    
	aag_current_state = (aag_start);
	aag_current_state += ((aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol);

	for ( aag_cp = (aagtext) + 0; aag_cp < (aag_c_buf_p); ++aag_cp )
		{
		register YY_CHAR aag_c = (*aag_cp ? aag_ec[((unsigned int) (unsigned char) *aag_cp)] : 1);
		if ( aag_accept[aag_current_state] )
			{
			(aag_last_accepting_state) = aag_current_state;
			(aag_last_accepting_cpos) = aag_cp;
			}
		while ( aag_chk[aag_base[aag_current_state] + aag_c] != aag_current_state )
			{
			aag_current_state = (int) aag_def[aag_current_state];
			if ( aag_current_state >= 93 )
				aag_c = aag_meta[(unsigned int) aag_c];
			}
		aag_current_state = aag_nxt[aag_base[aag_current_state] + (unsigned int) aag_c];
		}

	return aag_current_state;
}

/* aag_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = aag_try_NUL_trans( current_state );
 */
    static aag_state_type aag_try_NUL_trans  (aag_state_type aag_current_state )
{
	register int aag_is_jam;
    	register char *aag_cp = (aag_c_buf_p);

	register YY_CHAR aag_c = 1;
	if ( aag_accept[aag_current_state] )
		{
		(aag_last_accepting_state) = aag_current_state;
		(aag_last_accepting_cpos) = aag_cp;
		}
	while ( aag_chk[aag_base[aag_current_state] + aag_c] != aag_current_state )
		{
		aag_current_state = (int) aag_def[aag_current_state];
		if ( aag_current_state >= 93 )
			aag_c = aag_meta[(unsigned int) aag_c];
		}
	aag_current_state = aag_nxt[aag_base[aag_current_state] + (unsigned int) aag_c];
	aag_is_jam = (aag_current_state == 92);

		return aag_is_jam ? 0 : aag_current_state;
}

    static void aagunput (int c, register char * aag_bp )
{
	register char *aag_cp;
    
    aag_cp = (aag_c_buf_p);

	/* undo effects of setting up aagtext */
	*aag_cp = (aag_hold_char);

	if ( aag_cp < (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register aag_size_t number_to_move = (aag_n_chars) + 2;
		register char *dest = &(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[
					(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_size + 2];
		register char *source =
				&(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[number_to_move];

		while ( source > (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf )
			*--dest = *--source;

		aag_cp += (int) (dest - source);
		aag_bp += (int) (dest - source);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars =
			(aag_n_chars) = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_size;

		if ( aag_cp < (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf + 2 )
			aag_fatal_error( "flex scanner push-back overflow" );
		}

	*--aag_cp = (char) c;

	(aagtext) = aag_bp;
	(aag_hold_char) = *aag_cp;
	(aag_c_buf_p) = aag_cp;
}



    

    static int input  (void)


{
	int c;
    
	*(aag_c_buf_p) = (aag_hold_char);

	if ( *(aag_c_buf_p) == 0 )
		{
		/* aag_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (aag_c_buf_p) < &(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_ch_buf[(aag_n_chars)] )
			/* This was really a NUL. */
			*(aag_c_buf_p) = '\0';

		else
			{ /* need more input */
			aag_size_t offset = (aag_c_buf_p) - (aagtext);
			++(aag_c_buf_p);

			switch ( aag_get_next_buffer(  ) )
				{
				case 2:
					/* This happens because aag_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					aagrestart(aagin );

					/*FALLTHROUGH*/

				case 1:
					{
					if ( aagwrap( ) )
						return EOF;

					if ( ! (aag_did_buffer_switch_on_eof) )
						aagrestart(aagin );

					

					return input();

					}

				case 0:
					(aag_c_buf_p) = (aagtext) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (aag_c_buf_p);	/* cast for 8-bit char's */
	*(aag_c_buf_p) = '\0';	/* preserve aagtext */
	(aag_hold_char) = *++(aag_c_buf_p);

	(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_at_bol = (c == '\n');

	return c;
}


/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void aagrestart  (FILE * input_file )
{
    
	if ( ! ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) ){
        aagensure_buffer_stack ();
		(aag_buffer_stack)[(aag_buffer_stack_top)] =
            aag_create_buffer(aagin,16384 );
	}

	aag_init_buffer(( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL),input_file );
	aag_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void aag_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		aagpop_buffer_state();
	 *		aagpush_buffer_state(new_buffer);
     */
	aagensure_buffer_stack ();
	if ( ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) == new_buffer )
		return;

	if ( ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) )
		{
		/* Flush out information for old buffer. */
		*(aag_c_buf_p) = (aag_hold_char);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_pos = (aag_c_buf_p);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars = (aag_n_chars);
		}

	(aag_buffer_stack)[(aag_buffer_stack_top)] = new_buffer;
	aag_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (aagwrap()) processing, but the only time this flag
	 * is looked at is after aagwrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(aag_did_buffer_switch_on_eof) = 1;
}

static void aag_load_buffer_state  (void)
{
    	(aag_n_chars) = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars;
	(aagtext) = (aag_c_buf_p) = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_pos;
	aagin = (aag_buffer_stack)[(aag_buffer_stack_top)]->aag_input_file;
	(aag_hold_char) = *(aag_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE aag_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) aagalloc(sizeof( struct aag_buffer_state )  );
	if ( ! b )
		aag_fatal_error( "out of dynamic memory in aag_create_buffer()" );

	b->aag_buf_size = size;

	/* aag_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->aag_ch_buf = (char *) aagalloc(b->aag_buf_size + 2  );
	if ( ! b->aag_ch_buf )
		aag_fatal_error( "out of dynamic memory in aag_create_buffer()" );

	b->aag_is_our_buffer = 1;

	aag_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with aag_create_buffer()
 * 
 */
    void aag_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) ) /* Not sure if we should pop here. */
		(aag_buffer_stack)[(aag_buffer_stack_top)] = (YY_BUFFER_STATE) 0;

	if ( b->aag_is_our_buffer )
		aagfree((void *) b->aag_ch_buf  );

	aagfree((void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a aagrestart() or at EOF.
 */
    static void aag_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	aag_flush_buffer(b );

	b->aag_input_file = file;
	b->aag_fill_buffer = 1;

    /* If b is the current buffer, then aag_init_buffer was _probably_
     * called from aagrestart() or through aag_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL)){
        b->aag_bs_lineno = 1;
        b->aag_bs_column = 0;
    }

        b->aag_is_interactive = file ? (0 > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void aag_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->aag_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->aag_ch_buf[0] = 0;
	b->aag_ch_buf[1] = 0;

	b->aag_buf_pos = &b->aag_ch_buf[0];

	b->aag_at_bol = 1;
	b->aag_buffer_status = 0;

	if ( b == ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) )
		aag_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void aagpush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	aagensure_buffer_stack();

	/* This block is copied from aag_switch_to_buffer. */
	if ( ( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) )
		{
		/* Flush out information for old buffer. */
		*(aag_c_buf_p) = (aag_hold_char);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_buf_pos = (aag_c_buf_p);
		(aag_buffer_stack)[(aag_buffer_stack_top)]->aag_n_chars = (aag_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL))
		(aag_buffer_stack_top)++;
	(aag_buffer_stack)[(aag_buffer_stack_top)] = new_buffer;

	/* copied from aag_switch_to_buffer. */
	aag_load_buffer_state( );
	(aag_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void aagpop_buffer_state (void)
{
    	if (!( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL))
		return;

	aag_delete_buffer(( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) );
	(aag_buffer_stack)[(aag_buffer_stack_top)] = NULL;
	if ((aag_buffer_stack_top) > 0)
		--(aag_buffer_stack_top);

	if (( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL)) {
		aag_load_buffer_state( );
		(aag_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void aagensure_buffer_stack (void)
{
	aag_size_t num_to_alloc;
    
	if (!(aag_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(aag_buffer_stack) = (struct aag_buffer_state**)aagalloc
								(num_to_alloc * sizeof(struct aag_buffer_state*)
								);
		if ( ! (aag_buffer_stack) )
			aag_fatal_error( "out of dynamic memory in aagensure_buffer_stack()" );
								  
		memset((aag_buffer_stack), 0, num_to_alloc * sizeof(struct aag_buffer_state*));
				
		(aag_buffer_stack_max) = num_to_alloc;
		(aag_buffer_stack_top) = 0;
		return;
	}

	if ((aag_buffer_stack_top) >= ((aag_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (aag_buffer_stack_max) + grow_size;
		(aag_buffer_stack) = (struct aag_buffer_state**)aagrealloc
								((aag_buffer_stack),
								num_to_alloc * sizeof(struct aag_buffer_state*)
								);
		if ( ! (aag_buffer_stack) )
			aag_fatal_error( "out of dynamic memory in aagensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((aag_buffer_stack) + (aag_buffer_stack_max), 0, grow_size * sizeof(struct aag_buffer_state*));
		(aag_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE aag_scan_buffer  (char * base, aag_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != 0 ||
	     base[size-1] != 0 )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) aagalloc(sizeof( struct aag_buffer_state )  );
	if ( ! b )
		aag_fatal_error( "out of dynamic memory in aag_scan_buffer()" );

	b->aag_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->aag_buf_pos = b->aag_ch_buf = base;
	b->aag_is_our_buffer = 0;
	b->aag_input_file = 0;
	b->aag_n_chars = b->aag_buf_size;
	b->aag_is_interactive = 0;
	b->aag_at_bol = 1;
	b->aag_fill_buffer = 0;
	b->aag_buffer_status = 0;

	aag_switch_to_buffer(b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to aaglex() will
 * scan from a @e copy of @a str.
 * @param aagstr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       aag_scan_bytes() instead.
 */
YY_BUFFER_STATE aag_scan_string ( char * aagstr )
{
    
	return aag_scan_bytes(aagstr,strlen(aagstr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to aaglex() will
 * scan from a @e copy of @a bytes.
 * @param aagbytes the byte buffer to scan
 * @param _aagbytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE aag_scan_bytes  ( char * aagbytes, aag_size_t  _aagbytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	aag_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _aagbytes_len + 2;
	buf = (char *) aagalloc(n  );
	if ( ! buf )
		aag_fatal_error( "out of dynamic memory in aag_scan_bytes()" );

	for ( i = 0; i < _aagbytes_len; ++i )
		buf[i] = aagbytes[i];

	buf[_aagbytes_len] = buf[_aagbytes_len+1] = 0;

	b = aag_scan_buffer(buf,n );
	if ( ! b )
		aag_fatal_error( "bad buffer in aag_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->aag_is_our_buffer = 1;

	return b;
}





static void aag_fatal_error ( char* msg )
{
    	(void) fprintf( stderr, "%s\n", msg );
	exit( 2 );
}

/* Redefine aagless() so it works in section 3 code. */
















/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int aagget_lineno  (void)
{
        
    return aaglineno;
}

/** Get the input stream.
 * 
 */
FILE *aagget_in  (void)
{
        return aagin;
}

/** Get the output stream.
 * 
 */
FILE *aagget_out  (void)
{
        return aagout;
}

/** Get the length of the current token.
 * 
 */
aag_size_t aagget_leng  (void)
{
        return aagleng;
}

/** Get the current token.
 * 
 */

char *aagget_text  (void)
{
        return aagtext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void aagset_lineno (int  line_number )
{
    
    aaglineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see aag_switch_to_buffer
 */
void aagset_in (FILE *  in_str )
{
        aagin = in_str ;
}

void aagset_out (FILE *  out_str )
{
        aagout = out_str ;
}

int aagget_debug  (void)
{
        return aag_flex_debug;
}

void aagset_debug (int  bdebug )
{
        aag_flex_debug = bdebug ;
}

static int aag_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from aaglex_destroy(), so don't allocate here.
     */

    (aag_buffer_stack) = 0;
    (aag_buffer_stack_top) = 0;
    (aag_buffer_stack_max) = 0;
    (aag_c_buf_p) = (char *) 0;
    (aag_init) = 0;
    (aag_start) = 0;

/* Defined in main.c */

    
    

    aagin = (FILE *) 0;
    aagout = (FILE *) 0;


    /* For future reference: Set errno on error, since we are called by
     * aaglex_init()
     */
    return 0;
}

/* aaglex_destroy is for both reentrant and non-reentrant scanners. */
int aaglex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL)){
		aag_delete_buffer(( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL)  );
		(aag_buffer_stack)[(aag_buffer_stack_top)] = NULL;
		aagpop_buffer_state();
	}

	/* Destroy the stack itself. */
	aagfree((aag_buffer_stack) );
	(aag_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * aaglex() is called, initialization will occur. */
    aag_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */




	
	
		






	
	
		

	



void *aagalloc (aag_size_t  size )
{
	return (void *) malloc( size );
}

void *aagrealloc  (void * ptr, aag_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void aagfree (void * ptr )
{
	free( (char *) ptr );	/* see aagrealloc() for (char *) cast */
}






void aagerror(char *str)
{
	unsigned char	xbuf[BUFSIZ];
	char	buf[BUFSIZ];
	agxbuf  xb;

	agxbinit(&xb, BUFSIZ, xbuf);
	if (InputFile) {
		agxbput (&xb, InputFile);
		agxbput (&xb, ": ");
	}
	agxbput (&xb, str);
	sprintf(buf," in line %d near '", line_num);
	agxbput (&xb, buf);
	agxbput (&xb, aagtext);
	agxbput (&xb,"'\n");
	agerr(AGERR,(((((&xb)->ptr >= (&xb)->eptr) ? agxbmore(&xb,1) : 0), (int)(*(&xb)->ptr++ = ((unsigned char)'\0'))),(char*)((&xb)->ptr = (&xb)->buf)));
	agxbfree(&xb);
}
/* must be here to see flex's macro defns */
void aglexeof() { aagunput( '@', (aagtext) ); }

void aglexbad() { aag_flush_buffer(( (aag_buffer_stack) ? (aag_buffer_stack)[(aag_buffer_stack_top)] : NULL) ); }





int aagwrap(void)
{
	return 1;
}


